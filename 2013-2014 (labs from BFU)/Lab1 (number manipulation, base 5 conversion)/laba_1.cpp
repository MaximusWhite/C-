// лаба 1.cpp : Defines the entry point for the console application.

////Дано натуральное число. Если это число - не палиндром, то продублировать в нем цифры 8 и 0 и перевести в 5-ричную систему счисления,
//в противном случае найти ближайшее к нему меньшее простое число.

#include "stdafx.h"
#include <math.h> 
#include <iostream>
using std::cin;
using std::cout;

int OPVvod(); // функция ввода, возвращает число, которое пользователь вводит

bool OPPalindrom(int n);     // для проверки на палиндромность - если палиндром, то функция возвращает 'true'
int OPDubl80(int n);     // функции на вход даётся целое число, она дублирует 8-ки и нули и возвращает результат на выходе
int OP5(int n);         // функции на вход даётся целое число (уже с продублированными 8-ками и нулями) и переводит число в 5-тиричную систему
int OPBlizProstVniz(int n);
int OPBlizProstVverh(int n);
bool OPProst(int n);

void OPVivod(int n);      // процедура вывода конечного результата, которой в аргумент даётся число, которое получается после всех проведённых манипуляций

int _tmain(int argc, _TCHAR* argv[])
{
	int x;                // создаём переменную для своего числа, потом все манипуляции будут производиться с ним
	x = OPVvod();      //  записываем в неё результат функции 'OPVvod', то есть число, введённое пользователем
	if (OPPalindrom(x)) {       // далее проверка
								// если проверка на палиндромность возвращает положительный результат (OPPalindrom = true),
		                        // то найти ближайшее простое число (обращаемся к соответствующей функции, указывая в аргументе данное число)
		int x1 = OPBlizProstVniz(x);
		int x2 = OPBlizProstVverh(x);
		if ((x-x1)<(x2-x))  {

		OPVivod(x1);	
		}
        if ((x-x1)>(x2-x))  {

		OPVivod(x2);
		}

		if ((x-x1)==(x2-x))  {

		OPVivod(x1);
		OPVivod(x2);
		}



	} else {                  // иначе
		x = OPDubl80(x);     //  продублировать 8-ки и нули
		OPVivod(x);
		x = OP5(x);         // а потом перевести в 5-тиричную систему
		OPVivod(x);         // вызываем процедуру вывода
	}	
	system("PAUSE");   
	return 0;        
}

int OPVvod() {
	int n;     // создаём временную переменную
	cout<<"Vvedite chislo: ";
	cin>> n;  // записываем в неё число, данное пользователем
	return n;  // каждый раз при обращении к функции, она возвращает результат введённый пользователем
}

bool OPPalindrom(int n) {                      // проверяем палиндромность
   
   int perevertish = 0;                     // переменная в которую записывается временный результат (предполагаемый палиндром)
   
   int nachalnoe = n;                    //  клон исходного числа. над этим клоном будут проводиться операции результат которых будет сравнён с исходным числом

   for (int i = 0; nachalnoe!=0; i++)   {   // цикл пока клон не станет равен 0
    
       int l = nachalnoe % 10;            // временная переменная, берущая в себя значение последней цифры исходного числа
 
       nachalnoe = nachalnoe / 10;         // отсекаем последнюю цифру из клона исходного числа

       perevertish = perevertish * 10 + l;     // предпологаемый палиндром, в которой по одной забиваются цифры из клона, начиная с последней, и при каждом шаге 
                                               // предыдущий результат домножается на 10 (чтобы перевернуть разрядность)

   }
 
   if (perevertish == n){                      // если предполагаемый палиндром равен исходному числу, то исходное число является палиндромом
	   cout<<"Palindrom"<<"\n";
	   return true;   
   } 
   else{                                       // иначе - нет
       cout<< "Ne Palindrom"<<"\n";  
	   return false;
   }
}

int OPDubl80(int n) {
       
    int copy = n;                           //    временная переменная, копия исходного числа
    int resultat = 0;                           //   переменная для записи результата
    int i=0; 
	double bla = 10;
     while (copy!=0)  {      //   пока копия исходного числа не равна нулю, выполняется цикл
       int l = copy % 10;                   //   переменная для хранения последней цифры от копии на каждом шаге цикла
	  // OPVivod(l);
       copy = copy / 10;                    //   отсекаем последнюю цифру из копии исходного числа
        //OPVivod(copy);
	   if (l==8) {                      //   если последняя цифра равна 8, то она превращается в число 88, таким образом дублируются восьмёрки
		   l = 88;
	   }
       resultat = resultat + l * pow(bla,i);    // результат равен исходному, но с внесёнными изменениями
	   if (l==88 || l==0) {                      //   если последняя цифра равна 8, то она превращается в число 88, таким образом дублируются восьмёрки
		   i++;
	   }
       i++;
   }

	return resultat;                    // функция возвращает значение результатной переменной
}

int OP5(int n) {
	char temp[30];
    _itoa_s(n,temp,5);    // перевод в 5-тиричную систему счисления. функция возвращает результат в данную строку
    n = atof(temp);       // atof преобразовывает строку в число
	return n;
}

int OPBlizProstVniz(int n) {
	for (int j = 1; j<n; j++) {
		if (OPProst(n-j)) {
			return (n-j);
		}
	}
}

int OPBlizProstVverh(int n) {
	for (int j = 1; j<n; j++) {
		if (OPProst(n+j)) {
			return (n+j);
		}
	}
}

bool OPProst(int n) {
	for (int i = 2; i <= n-1; i++) {
		if (n % i == 0)
			return false;
	}
	return true;
}

void OPVivod(int n) {
	cout<<"Resultat: "<< n <<"\n";
}

