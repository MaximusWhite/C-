// lab03_14.cpp : Defines the entry point for the console application.
//Дана целочисленная матрица R размером n x n (n<=8). Если под
//главной диагональю матрицы есть отрицательные числа, то поменять
//местами столбцы с наибольшей и наименьшей суммой элементов.

#include "stdafx.h"
#include <iostream>    
#include <string>
#include <stdio.h>
#include<sstream>
#include<cstdlib>
using namespace std;


bool CheckNegative(int **a, int n);  // функция определяющая, есть ли отрицательные числа под главной диагональю матрицы
void Change(int **a, int n);         // процедура, меняющая столбцы с минимальной и максимальной суммой местами, если таковые имеются



int _tmain(int argc, _TCHAR* argv[])
{
	setlocale(LC_ALL,"Russian");
	 int v, n;                       // n - размер массива; v - временная переменная для значения вводимого пользователем
	 cout<<"Введите размер массива:";
	 cin>>n;
	 int** a = new int* [n];         // выделяем память под двумерный массив
	 for(int i = 0; i < n; i++)
		{
			a[i] = new int [n];
		}
	 cout<<"Введите элементы массива:"<<endl;    // считываем значения элементов массива по одному от пользователя
	 for(int i = 0; i < n; i++)
	 {
		for(int k = 0; k < n; k++)
			 {
			 cout<<i+1<<", "<<k+1<<":";
			 cin>>v;
			 a[i][k] = v;
			 }
	 }
	 cout << "Исходный массив:" << endl;     // выводим исходный массив на экран
	 for(int i = 0; i < n; i++)
	 {
		 for(int k = 0; k < n; k++)
			 {
			 cout << a[i][k] << " ";
			 }
		 cout << endl;
	 }

	 if (CheckNegative(a, n))                 // если хотя бы одно отрицательное число под диагонялью матрицы найдено, то
	 {

		 cout<<"Массив после перестановки столбцов:"<<endl;
			Change(a,n);                      // меняем местами столбцы с минимальной и максимальной суммами

	 }else cout<<"Под диагональю матрицы нет отрицательных элементов."<<endl;    // иначе, ничего не надо делать
		
	for(int i = 0; i < n; i++)     // освобождаем память, выделенную под массив
		{
			delete [] a[i];
		}
	delete [] a;

	system("pause");

	return 0;
}


bool CheckNegative(int **a, int n)         
{
	 for(int i = 0; i < n; i++)             
	 {                                      
		for(int k = 0; k < i; k++)            //  если элемент находится в таком месте, что порядковый номер столбца меньше номера строки
			 {
				 if (a[i][k]<0)	return true;  //  и этот элемент является отрицательным, то функция возвращает true  

			 }
	 }

	
   return false;                              // иначе, false


}


void Change(int **a, int n)
{
    int min=0, max=0;             // порядковые номера столбцов с минимальной и максимальной суммами 
	int sum=0;                    // временная сумма столбца
	int sum_min=0, sum_max=0;     // минимальная и максимальная суммы
    
	for (int i=0; i<n; i++)       // изначально условимся, что сумма первого столбца является и максимальной и минимальной
	{  
        
		sum_min+=a[i][0];         // найдём эти суммы
		sum_max=sum_min;

	}

	for (int k=0; k<n; k++)       // в каждом из столбцов делаем следующее:
	{                             
		sum = 0;                  // временная сумма столбца обнуляется
		 
		for (int i=0; i<n; i++)   // идём построчно по матрице вниз
		 {
            
             sum+=a[i][k];        // находим сумму столбца

		 }

        if (sum>sum_max)          // если временная сумма столбца больше предпологаемой максимальной, то:
		{
			sum_max = sum;        // обновляем максимальную сумму 
			max=k;                // обновляем порядковый номер столбца с максимальной суммой
		}

		 if (sum<sum_min)         // аналогично предыдущему блоку, только с минимальной суммой ^
		{
			sum_min = sum;
			min=k;
		}

	}


    if (min==max)                 // если порядковые номера столбцов с максимальной и минимальной суммой равны (то есть, по факту - все столбцы одинаковые)
	{
		cout<<"Максимальная и минимальная суммы равны. Матрица остается неизменна."<<endl;   // то выводим сообщение о том, что изменений не требуется
		return;                  // и выходим из функции
	}
  
	for (int i=0; i<n; i++)      // если же они разные, то функция просто продолжается
	{
	swap(a[i][min],a[i][max]);   // и мы построчно меняем элементы с индексами min и max местами
	}
	for(int i = 0; i < n; i++)   // выводим на экран изменённый массив
	 {
			for(int k = 0; k < n; k++)
			 {
				cout << a[i][k] << " ";
			 }
		 cout << endl;
	} 

}